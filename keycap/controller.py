import numpy as np
from keycap import keycap_function, generate_model
import random

class Controller:
    """
    A controller class to manage parameters and constraints for the keycap model. This is the core of the keyboard model, without this class the keyboard model would not work, as it would generate incorrect values.
    This class is to correct and constrain the values generated by the keycap model.
    
  
    Methods:
    - __init__(self, n, D, alpha, w, min_velocity=1, max_velocity=100): Initializes the Controller with a given number of keycaps.
    - generate_D(self, lower=0.1, upper=5): Randomly generates D values between the specified bounds.
    - generate_alpha(self, constant_value=1): Generates alpha values.
    - generate_w(self, start_value=1, random_range=(0.1, 0.5)): Generates w values based on an increasing pattern with randomness.
    - generate_model_values(self, t): Generates model values for the given time series using the current D, alpha, and w, and applies velocity constraints.
    """
    def __init__(self, n=None, D=None, alpha=None, w=None, min_velocity=1, max_velocity=100):
        """
        Initializes the Controller with a given number of keycaps.
        
        Parameters:
        - n (int): Number of keycap functions.
        - D (list of floats): List of amplitude factors.
        - alpha (list of floats): List of parameters affecting the shape of the keycap.
        - w (list of floats): List of frequencies.
        - min_velocity (float): Minimum allowed velocity for model values.
        - max_velocity (float): Maximum allowed velocity for model values.
        """
        if (n is None):
            self.generate_n()
        else:
            self.n = n
            
        if (D is None):
            self.generate_D()
        else:
            self.D = D
        
        if (alpha is None):
            self.generate_alpha()
        else:
            self.alpha = alpha
    
        if (w is None):
            self.generate_w()
        else:
            self.w = w

        self.min_velocity = min_velocity
        self.max_velocity = max_velocity

        self.loaded_config = False  # Attribute to check if a config was loaded

    def generate_n(self, lower=500, upper=5000):
        """
        Randomly generates n values between the specified bounds.
        
        Parameters:
        - lower (int): Lower bound for n.
        - upper (int): Upper bound for n.
        """
        self.n = random.randint(lower, upper)

    def generate_D(self, lower=0.1, upper=5):
        """
        Randomly generates D values between the specified bounds.
        
        Parameters:
        - lower (float): Lower bound for D.
        - upper (float): Upper bound for D.
        """
        self.D = np.random.uniform(lower, upper, self.n)

    def add_gaussian_noise(self, data, mean_variation=0.1, std_variation=0.5):
        """
        Adds Gaussian noise to the given data.
        Important to guarantee variation to a user session.
        
        Parameters:
        - data (array-like): Original data to which Gaussian noise will be added.
        - mean_variation (float): Mean of Gaussian noise.
        - std_variation (float): Standard deviation of Gaussian noise.
        
        Returns:
        - (array-like): Data with Gaussian noise.
        """
        gaussian_noise = np.random.normal(mean_variation, std_variation, len(data))
        return data + gaussian_noise



    def generate_alpha(self, constant_value=1):
        """
        Generates alpha values. This example uses a constant value for simplicity, but can be extended.
        
        Parameters:
        - constant_value (float): The constant value for all alpha values.
        """
        self.alpha = np.full(self.n, constant_value)

    def generate_w(self, start_value=1, lower=0.1, upper=0.5):
        """
        Generates w values based on an increasing pattern with randomness.
        The greater the values of w, the faster the keyboard writes as we approach higher frequencies.
        
        Parameters:
        - start_value (float): Starting value for w.
        - random_range (tuple of float): Range to generate randomness for w.
        """
        random_values = np.random.uniform(lower, upper, self.n)
        self.w = np.array([start_value + i + random_values[i] for i in range(self.n)])
    


    def generate_model_values(self, t, d_mean_variation=0.1, d_std_variation=1, w_mean_variation=0.1, w_std_variation=0.1):
        """
        Generates model values for the given time series using the current D, alpha, and w, and applies velocity constraints.
        
        Parameters:
        - t (array-like): Time series data.
        
        Returns:
        - (array-like): Values of the model for the given time series.
        """
        if self.D is None or self.alpha is None or self.w is None:
            raise ValueError("Ensure D, alpha, and w are generated before calling the model.")
        
        # Apply variations to D and w
        D_with_noise = self.add_gaussian_noise(self.D, d_mean_variation, d_std_variation)
        w_with_noise = self.add_gaussian_noise(self.w, w_mean_variation, w_std_variation)
        
        model_values = generate_model(t, self.n, D_with_noise, self.alpha, w_with_noise)
        
        # Replace values below min_velocity with min_velocity
        model_values[model_values < self.min_velocity] = self.min_velocity

        # Replace values above max_velocity with max_velocity
        model_values[model_values > self.max_velocity] = self.max_velocity
        
        return model_values
    
    def save_configuration(self, manager, name):
        """
        Save the current configuration using a given ConfigurationManager.
        
        Parameters:
        - manager (ConfigurationManager): Instance of the ConfigurationManager.
        - name (str): Name under which to save the configuration.
        """
        manager.save(name, self)

    @classmethod
    def load_configuration(cls, manager, name):
        """
        Load a configuration using a given ConfigurationManager.
        
        Parameters:
        - manager (ConfigurationManager): Instance of the ConfigurationManager.
        - name (str): Name of the saved configuration.

        Returns:
        - (Controller): A new Controller instance with the loaded configuration.
        """
        loaded_instance = manager.load(name)
        loaded_instance.loaded_config = True  # Set the loaded_config attribute to True
        return loaded_instance


class ConfigurationManager:
    """A class to manage configurations for controllers.

    This class provides methods to save and load configurations for controllers.
    It is important to save this because a session must use the same configuration and retain the same characteristics.
    Configurations are stored as dictionaries with the following keys:
    - 'n': the number of notes in the controller
    - 'D': a list with the damping coefficients for each note
    - 'alpha': a list with the stiffness coefficients for each note
    - 'w': a list with the natural frequencies for each note
    - 'min_velocity': the minimum velocity for the controller
    - 'max_velocity': the maximum velocity for the controller

    Example usage:
    >>> config_manager = ConfigurationManager()
    >>> controller = Controller(n=3, D=[0.1, 0.2, 0.2], alpha=[1.0, 1.0, 1.0], w=[0.1, 0.2, 0.3], min_velocity=1.0, max_velocity=100.0)
    >>> config_manager.save('XXXX', controller)
    >>> loaded_controller = config_manager.load('XXXX')
    """

    def __init__(self):
        self.configurations = {}  # Dictionary to store configurations

    def save(self, name, controller):
        """Save a controller's configuration under a specified name."""
        config = {
            "n": controller.n,
            "D": controller.D.tolist(),
            "alpha": controller.alpha.tolist(),
            "w": controller.w.tolist(),
            "min_velocity": controller.min_velocity,
            "max_velocity": controller.max_velocity
        }
        self.configurations[name] = config

    def load(self, name):
        """Load a controller's configuration by its name."""
        if name not in self.configurations:
            raise ValueError(f"Configuration '{name}' not found!")
        
        config = self.configurations[name]

        return Controller(
            n=config["n"],
            D=np.array(config["D"]),
            alpha=np.array(config["alpha"]),
            w=np.array(config["w"]),
            min_velocity=config["min_velocity"],
            max_velocity=config["max_velocity"]
        )
